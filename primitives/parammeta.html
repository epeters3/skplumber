<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>skplumber.primitives.parammeta API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skplumber.primitives.parammeta</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC, abstractmethod
import typing as t

import pandas as pd


class ParamMeta(ABC):
    &#34;&#34;&#34;
    An asbtract base class for describing the metadata of
    a primitive hyperparameter. Allows hyperparameters to
    be more easily sampled or optimized. A given
    hyperparameter only needs to be described in this way
    if the implementer wants it to be automatically samplable
    and optimizable by the SKPlumber package. Any hyperparameters
    not described in this way can still be set manually by the
    user.
    &#34;&#34;&#34;

    @abstractmethod
    def with_data(self, X: pd.DataFrame) -&gt; &#34;ParamMeta&#34;:
        &#34;&#34;&#34;
        Should return a copy of self but with all attributes
        represented in hard, literal values, given that `X` is
        being passed in. E.g. an `int` instead of a function
        that computes an `int`, given `X`.
        &#34;&#34;&#34;
        pass


class NumericParamMeta(ParamMeta):
    &#34;&#34;&#34;
    Abstract base class for describing the metadata of a
    numeric primitive hyperparameter (e.g. a float or int).
    &#34;&#34;&#34;

    def __init__(
        self,
        lbound: t.Union[int, float, t.Callable],
        ubound: t.Union[int, float, t.Callable],
    ) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        lbound
            The lower bound that the hyperparameter&#39;s value can
            take on.
        ubound
            The upper bound that the hyperparameter&#39;s value can
            take on.

        Sometimes the bounds of a hyperparameter are dependent on
        the dataset being trained on. If `lbound` or `ubound` is
        a function, it will be called, passing the training data
        (i.e. the `X` Pandas DataFrame) as the first and only
        argument. This so the bound can be computed having the
        context of the input dataset.
        &#34;&#34;&#34;
        self.lbound: t.Union[int, float, t.Callable] = lbound
        self.ubound: t.Union[int, float, t.Callable] = ubound

    def with_data(self, X: pd.DataFrame) -&gt; &#34;NumericParamMeta&#34;:
        lbound = self.lbound(X) if callable(self.lbound) else self.lbound
        ubound = self.ubound(X) if callable(self.ubound) else self.ubound
        # `type(self)` ensures a `IntParamMeta` or `FloatParamMeta` is
        # returned. Source:
        # https://stackoverflow.com/questions/7840911/python-inheritance-return-subclass
        return type(self)(lbound, ubound)


class CategoricalParamMeta(ParamMeta):
    def __init__(self, options: t.Iterable[t.Any]) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        options : iterable object
            The options that this hyperparameter can take on.
        &#34;&#34;&#34;
        self.options = set(options)

    def with_data(self, X: pd.DataFrame) -&gt; &#34;CategoricalParamMeta&#34;:
        options = [o(X) if callable(o) else o for o in self.options]
        return CategoricalParamMeta(options)


class BoolParamMeta(ParamMeta):
    def with_data(self, X: pd.DataFrame) -&gt; &#34;BoolParamMeta&#34;:
        &#34;&#34;&#34;
        Bools don&#39;t use `X` in any way, so no copy needed.
        &#34;&#34;&#34;
        return self


class IntParamMeta(NumericParamMeta):
    def __init__(
        self, lbound: t.Union[int, t.Callable], ubound: t.Union[int, t.Callable]
    ) -&gt; None:
        super().__init__(lbound, ubound)


class FloatParamMeta(NumericParamMeta):
    def __init__(
        self, lbound: t.Union[float, t.Callable], ubound: t.Union[float, t.Callable]
    ) -&gt; None:
        super().__init__(lbound, ubound)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skplumber.primitives.parammeta.BoolParamMeta"><code class="flex name class">
<span>class <span class="ident">BoolParamMeta</span></span>
</code></dt>
<dd>
<div class="desc"><p>An asbtract base class for describing the metadata of
a primitive hyperparameter. Allows hyperparameters to
be more easily sampled or optimized. A given
hyperparameter only needs to be described in this way
if the implementer wants it to be automatically samplable
and optimizable by the SKPlumber package. Any hyperparameters
not described in this way can still be set manually by the
user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoolParamMeta(ParamMeta):
    def with_data(self, X: pd.DataFrame) -&gt; &#34;BoolParamMeta&#34;:
        &#34;&#34;&#34;
        Bools don&#39;t use `X` in any way, so no copy needed.
        &#34;&#34;&#34;
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skplumber.primitives.parammeta.BoolParamMeta.with_data"><code class="name flex">
<span>def <span class="ident">with_data</span></span>(<span>self, X: pandas.core.frame.DataFrame) -> <a title="skplumber.primitives.parammeta.BoolParamMeta" href="#skplumber.primitives.parammeta.BoolParamMeta">BoolParamMeta</a></span>
</code></dt>
<dd>
<div class="desc"><p>Bools don't use <code>X</code> in any way, so no copy needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_data(self, X: pd.DataFrame) -&gt; &#34;BoolParamMeta&#34;:
    &#34;&#34;&#34;
    Bools don&#39;t use `X` in any way, so no copy needed.
    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="skplumber.primitives.parammeta.CategoricalParamMeta"><code class="flex name class">
<span>class <span class="ident">CategoricalParamMeta</span></span>
<span>(</span><span>options: Iterable[Any])</span>
</code></dt>
<dd>
<div class="desc"><p>An asbtract base class for describing the metadata of
a primitive hyperparameter. Allows hyperparameters to
be more easily sampled or optimized. A given
hyperparameter only needs to be described in this way
if the implementer wants it to be automatically samplable
and optimizable by the SKPlumber package. Any hyperparameters
not described in this way can still be set manually by the
user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>iterable object</code></dt>
<dd>The options that this hyperparameter can take on.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CategoricalParamMeta(ParamMeta):
    def __init__(self, options: t.Iterable[t.Any]) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        options : iterable object
            The options that this hyperparameter can take on.
        &#34;&#34;&#34;
        self.options = set(options)

    def with_data(self, X: pd.DataFrame) -&gt; &#34;CategoricalParamMeta&#34;:
        options = [o(X) if callable(o) else o for o in self.options]
        return CategoricalParamMeta(options)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></b></code>:
<ul class="hlist">
<li><code><a title="skplumber.primitives.parammeta.ParamMeta.with_data" href="#skplumber.primitives.parammeta.ParamMeta.with_data">with_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skplumber.primitives.parammeta.FloatParamMeta"><code class="flex name class">
<span>class <span class="ident">FloatParamMeta</span></span>
<span>(</span><span>lbound: Union[float, Callable], ubound: Union[float, Callable])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for describing the metadata of a
numeric primitive hyperparameter (e.g. a float or int).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lbound</code></strong></dt>
<dd>The lower bound that the hyperparameter's value can
take on.</dd>
<dt><strong><code>ubound</code></strong></dt>
<dd>The upper bound that the hyperparameter's value can
take on.</dd>
</dl>
<p>Sometimes the bounds of a hyperparameter are dependent on
the dataset being trained on. If <code>lbound</code> or <code>ubound</code> is
a function, it will be called, passing the training data
(i.e. the <code>X</code> Pandas DataFrame) as the first and only
argument. This so the bound can be computed having the
context of the input dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FloatParamMeta(NumericParamMeta):
    def __init__(
        self, lbound: t.Union[float, t.Callable], ubound: t.Union[float, t.Callable]
    ) -&gt; None:
        super().__init__(lbound, ubound)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skplumber.primitives.parammeta.NumericParamMeta" href="#skplumber.primitives.parammeta.NumericParamMeta">NumericParamMeta</a></li>
<li><a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skplumber.primitives.parammeta.NumericParamMeta" href="#skplumber.primitives.parammeta.NumericParamMeta">NumericParamMeta</a></b></code>:
<ul class="hlist">
<li><code><a title="skplumber.primitives.parammeta.NumericParamMeta.with_data" href="#skplumber.primitives.parammeta.ParamMeta.with_data">with_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skplumber.primitives.parammeta.IntParamMeta"><code class="flex name class">
<span>class <span class="ident">IntParamMeta</span></span>
<span>(</span><span>lbound: Union[int, Callable], ubound: Union[int, Callable])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for describing the metadata of a
numeric primitive hyperparameter (e.g. a float or int).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lbound</code></strong></dt>
<dd>The lower bound that the hyperparameter's value can
take on.</dd>
<dt><strong><code>ubound</code></strong></dt>
<dd>The upper bound that the hyperparameter's value can
take on.</dd>
</dl>
<p>Sometimes the bounds of a hyperparameter are dependent on
the dataset being trained on. If <code>lbound</code> or <code>ubound</code> is
a function, it will be called, passing the training data
(i.e. the <code>X</code> Pandas DataFrame) as the first and only
argument. This so the bound can be computed having the
context of the input dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntParamMeta(NumericParamMeta):
    def __init__(
        self, lbound: t.Union[int, t.Callable], ubound: t.Union[int, t.Callable]
    ) -&gt; None:
        super().__init__(lbound, ubound)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skplumber.primitives.parammeta.NumericParamMeta" href="#skplumber.primitives.parammeta.NumericParamMeta">NumericParamMeta</a></li>
<li><a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skplumber.primitives.parammeta.NumericParamMeta" href="#skplumber.primitives.parammeta.NumericParamMeta">NumericParamMeta</a></b></code>:
<ul class="hlist">
<li><code><a title="skplumber.primitives.parammeta.NumericParamMeta.with_data" href="#skplumber.primitives.parammeta.ParamMeta.with_data">with_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skplumber.primitives.parammeta.NumericParamMeta"><code class="flex name class">
<span>class <span class="ident">NumericParamMeta</span></span>
<span>(</span><span>lbound: Union[int, float, Callable], ubound: Union[int, float, Callable])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for describing the metadata of a
numeric primitive hyperparameter (e.g. a float or int).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lbound</code></strong></dt>
<dd>The lower bound that the hyperparameter's value can
take on.</dd>
<dt><strong><code>ubound</code></strong></dt>
<dd>The upper bound that the hyperparameter's value can
take on.</dd>
</dl>
<p>Sometimes the bounds of a hyperparameter are dependent on
the dataset being trained on. If <code>lbound</code> or <code>ubound</code> is
a function, it will be called, passing the training data
(i.e. the <code>X</code> Pandas DataFrame) as the first and only
argument. This so the bound can be computed having the
context of the input dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumericParamMeta(ParamMeta):
    &#34;&#34;&#34;
    Abstract base class for describing the metadata of a
    numeric primitive hyperparameter (e.g. a float or int).
    &#34;&#34;&#34;

    def __init__(
        self,
        lbound: t.Union[int, float, t.Callable],
        ubound: t.Union[int, float, t.Callable],
    ) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        lbound
            The lower bound that the hyperparameter&#39;s value can
            take on.
        ubound
            The upper bound that the hyperparameter&#39;s value can
            take on.

        Sometimes the bounds of a hyperparameter are dependent on
        the dataset being trained on. If `lbound` or `ubound` is
        a function, it will be called, passing the training data
        (i.e. the `X` Pandas DataFrame) as the first and only
        argument. This so the bound can be computed having the
        context of the input dataset.
        &#34;&#34;&#34;
        self.lbound: t.Union[int, float, t.Callable] = lbound
        self.ubound: t.Union[int, float, t.Callable] = ubound

    def with_data(self, X: pd.DataFrame) -&gt; &#34;NumericParamMeta&#34;:
        lbound = self.lbound(X) if callable(self.lbound) else self.lbound
        ubound = self.ubound(X) if callable(self.ubound) else self.ubound
        # `type(self)` ensures a `IntParamMeta` or `FloatParamMeta` is
        # returned. Source:
        # https://stackoverflow.com/questions/7840911/python-inheritance-return-subclass
        return type(self)(lbound, ubound)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="skplumber.primitives.parammeta.FloatParamMeta" href="#skplumber.primitives.parammeta.FloatParamMeta">FloatParamMeta</a></li>
<li><a title="skplumber.primitives.parammeta.IntParamMeta" href="#skplumber.primitives.parammeta.IntParamMeta">IntParamMeta</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></b></code>:
<ul class="hlist">
<li><code><a title="skplumber.primitives.parammeta.ParamMeta.with_data" href="#skplumber.primitives.parammeta.ParamMeta.with_data">with_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skplumber.primitives.parammeta.ParamMeta"><code class="flex name class">
<span>class <span class="ident">ParamMeta</span></span>
</code></dt>
<dd>
<div class="desc"><p>An asbtract base class for describing the metadata of
a primitive hyperparameter. Allows hyperparameters to
be more easily sampled or optimized. A given
hyperparameter only needs to be described in this way
if the implementer wants it to be automatically samplable
and optimizable by the SKPlumber package. Any hyperparameters
not described in this way can still be set manually by the
user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamMeta(ABC):
    &#34;&#34;&#34;
    An asbtract base class for describing the metadata of
    a primitive hyperparameter. Allows hyperparameters to
    be more easily sampled or optimized. A given
    hyperparameter only needs to be described in this way
    if the implementer wants it to be automatically samplable
    and optimizable by the SKPlumber package. Any hyperparameters
    not described in this way can still be set manually by the
    user.
    &#34;&#34;&#34;

    @abstractmethod
    def with_data(self, X: pd.DataFrame) -&gt; &#34;ParamMeta&#34;:
        &#34;&#34;&#34;
        Should return a copy of self but with all attributes
        represented in hard, literal values, given that `X` is
        being passed in. E.g. an `int` instead of a function
        that computes an `int`, given `X`.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="skplumber.primitives.parammeta.BoolParamMeta" href="#skplumber.primitives.parammeta.BoolParamMeta">BoolParamMeta</a></li>
<li><a title="skplumber.primitives.parammeta.CategoricalParamMeta" href="#skplumber.primitives.parammeta.CategoricalParamMeta">CategoricalParamMeta</a></li>
<li><a title="skplumber.primitives.parammeta.NumericParamMeta" href="#skplumber.primitives.parammeta.NumericParamMeta">NumericParamMeta</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skplumber.primitives.parammeta.ParamMeta.with_data"><code class="name flex">
<span>def <span class="ident">with_data</span></span>(<span>self, X: pandas.core.frame.DataFrame) -> <a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></span>
</code></dt>
<dd>
<div class="desc"><p>Should return a copy of self but with all attributes
represented in hard, literal values, given that <code>X</code> is
being passed in. E.g. an <code>int</code> instead of a function
that computes an <code>int</code>, given <code>X</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def with_data(self, X: pd.DataFrame) -&gt; &#34;ParamMeta&#34;:
    &#34;&#34;&#34;
    Should return a copy of self but with all attributes
    represented in hard, literal values, given that `X` is
    being passed in. E.g. an `int` instead of a function
    that computes an `int`, given `X`.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skplumber.primitives" href="index.html">skplumber.primitives</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skplumber.primitives.parammeta.BoolParamMeta" href="#skplumber.primitives.parammeta.BoolParamMeta">BoolParamMeta</a></code></h4>
<ul class="">
<li><code><a title="skplumber.primitives.parammeta.BoolParamMeta.with_data" href="#skplumber.primitives.parammeta.BoolParamMeta.with_data">with_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skplumber.primitives.parammeta.CategoricalParamMeta" href="#skplumber.primitives.parammeta.CategoricalParamMeta">CategoricalParamMeta</a></code></h4>
</li>
<li>
<h4><code><a title="skplumber.primitives.parammeta.FloatParamMeta" href="#skplumber.primitives.parammeta.FloatParamMeta">FloatParamMeta</a></code></h4>
</li>
<li>
<h4><code><a title="skplumber.primitives.parammeta.IntParamMeta" href="#skplumber.primitives.parammeta.IntParamMeta">IntParamMeta</a></code></h4>
</li>
<li>
<h4><code><a title="skplumber.primitives.parammeta.NumericParamMeta" href="#skplumber.primitives.parammeta.NumericParamMeta">NumericParamMeta</a></code></h4>
</li>
<li>
<h4><code><a title="skplumber.primitives.parammeta.ParamMeta" href="#skplumber.primitives.parammeta.ParamMeta">ParamMeta</a></code></h4>
<ul class="">
<li><code><a title="skplumber.primitives.parammeta.ParamMeta.with_data" href="#skplumber.primitives.parammeta.ParamMeta.with_data">with_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>